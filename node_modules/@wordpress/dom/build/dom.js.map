{"version":3,"sources":["@wordpress/dom/src/dom.js"],"names":["window","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isEdge","container","isReverse","onlyVertical","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","rangeCount","range","getRangeAt","cloneRange","isForward","isCollapsed","collapse","rangeRect","getRectangleFromRange","computedStyle","lineHeight","parseInt","height","padding","buffer","containerRect","getBoundingClientRect","verticalEdge","top","bottom","x","left","right","y","testRange","hiddenCaretRangeFromPoint","document","side","testRect","Math","round","isHorizontalEdge","isVerticalEdge","collapsed","startContainer","nodeName","parentNode","index","Array","from","childNodes","indexOf","createRange","setStart","setEnd","rect","getClientRects","padNode","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","style","zIndex","placeCaretAtVerticalEdge","mayUseScroll","editableRect","contains","scrollIntoView","nodeType","parentRect","getPropertyValue","actualY","isTextField","element","contentEditable","error","documentHasSelection","activeElement","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","data","firstChild","getScrollContainer","node","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","ownerDocument","createElement","appendChild","replaceChild","wrap"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Browser dependencies\n */\n\nconst { getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst {\n\t\tanchorNode,\n\t\tfocusNode,\n\t\tanchorOffset,\n\t\tfocusOffset,\n\t} = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 ).cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\trange.collapse( ! isForward );\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst computedStyle = window.getComputedStyle( container );\n\tconst lineHeight = parseInt( computedStyle.lineHeight, 10 ) || 0;\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge.\n\tif (\n\t\t! isCollapsed &&\n\t\trangeRect.height > lineHeight &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\tconst padding = parseInt( computedStyle[\n\t\t`padding${ isReverse ? 'Top' : 'Bottom' }`\n\t], 10 ) || 0;\n\n\t// Calculate a buffer that is half the line height. In some browsers, the\n\t// selection rectangle may not fill the entire height of the line, so we add\n\t// 3/4 the line height to the selection rectangle to ensure that it is well\n\t// over its line boundary.\n\tconst buffer = 3 * parseInt( lineHeight, 10 ) / 4;\n\tconst containerRect = container.getBoundingClientRect();\n\tconst verticalEdge = isReverse ?\n\t\tcontainerRect.top + padding > rangeRect.top - buffer :\n\t\tcontainerRect.bottom - padding < rangeRect.bottom + buffer;\n\n\tif ( ! verticalEdge ) {\n\t\treturn false;\n\t}\n\n\tif ( onlyVertical ) {\n\t\treturn true;\n\t}\n\n\t// To calculate the horizontal position, we insert a test range and see if\n\t// this test range has the same horizontal position. This method proves to\n\t// be better than a DOM-based calculation, because it ignores empty text\n\t// nodes and a trailing line break element. In other words, we need to check\n\t// visual positioning, not DOM positioning.\n\tconst x = isReverse ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + buffer : containerRect.bottom - buffer;\n\tconst testRange = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst side = isReverse ? 'left' : 'right';\n\tconst testRect = getRectangleFromRange( testRange );\n\n\treturn Math.round( testRect[ side ] ) === Math.round( rangeRect[ side ] );\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf( startContainer );\n\n\t\trange = document.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Element} container Editable container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect( container ) {\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tcontainer.style.zIndex = '10000';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = null;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge( container, isReverse, rect, mayUseScroll = true ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse ? ( editableRect.bottom - buffer ) : ( editableRect.top + buffer );\n\n\tlet range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif ( mayUseScroll && (\n\t\t\t( ! range || ! range.startContainer ) ||\n\t\t\t\t! range.startContainer.contains( container ) ) ) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Check if the closest text node is actually further away.\n\t// If so, attempt to get the range again with the y position adjusted to get the right offset.\n\tif ( range.startContainer.nodeType === TEXT_NODE ) {\n\t\tconst parentNode = range.startContainer.parentNode;\n\t\tconst parentRect = parentNode.getBoundingClientRect();\n\t\tconst side = isReverse ? 'bottom' : 'top';\n\t\tconst padding = parseInt( getComputedStyle( parentNode ).getPropertyValue( `padding-${ side }` ), 10 ) || 0;\n\t\tconst actualY = isReverse ? ( parentRect.bottom - padding - buffer ) : ( parentRect.top + padding + buffer );\n\n\t\tif ( y !== actualY ) {\n\t\t\trange = hiddenCaretRangeFromPoint( document, x, actualY, container );\n\t\t}\n\t}\n\n\tconst selection = window.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\ttry {\n\t\tconst { nodeName, selectionStart, contentEditable } = element;\n\n\t\treturn (\n\t\t\t( nodeName === 'INPUT' && selectionStart !== null ) ||\n\t\t\t( nodeName === 'TEXTAREA' ) ||\n\t\t\tcontentEditable === 'true'\n\t\t);\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check wether the current document has a selection.\n * This checks both for focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\tif ( isTextField( document.activeElement ) ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn element.selectionStart === 0 && element.value.length === element.selectionEnd;\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength = lastChild.nodeType === TEXT_NODE ?\n\t\tlastChild.data.length :\n\t\tlastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n"]}